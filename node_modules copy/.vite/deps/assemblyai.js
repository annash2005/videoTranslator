import {
  __commonJS,
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/assemblyai/dist/index.mjs
var import_ws = __toESM(require_browser(), 1);
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var buildUserAgent = (userAgent) => defaultUserAgentString + (userAgent === false ? "" : " AssemblyAI/1.0 (" + Object.entries(Object.assign(Object.assign({}, defaultUserAgent), userAgent)).map(([key, item]) => item ? `${key}=${item.name}/${item.version}` : "").join(" ") + ")");
var defaultUserAgentString = "";
if (typeof navigator !== "undefined" && navigator.userAgent) {
  defaultUserAgentString += navigator.userAgent;
}
var defaultUserAgent = {
  sdk: { name: "JavaScript", version: "4.4.5" }
};
if (typeof process !== "undefined") {
  if (process.versions.node && defaultUserAgentString.indexOf("Node") === -1) {
    defaultUserAgent.runtime_env = {
      name: "Node",
      version: process.versions.node
    };
  }
  if (process.versions.bun && defaultUserAgentString.indexOf("Bun") === -1) {
    defaultUserAgent.runtime_env = {
      name: "Bun",
      version: process.versions.bun
    };
  }
}
if (typeof Deno !== "undefined") {
  if (process.versions.bun && defaultUserAgentString.indexOf("Deno") === -1) {
    defaultUserAgent.runtime_env = { name: "Deno", version: Deno.version.deno };
  }
}
var BaseService = class {
  constructor(params) {
    this.params = params;
    if (params.userAgent === false) {
      this.userAgent = void 0;
    } else {
      this.userAgent = buildUserAgent(params.userAgent || {});
    }
  }
  fetch(input, init) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      init = init !== null && init !== void 0 ? init : {};
      let headers = (_a = init.headers) !== null && _a !== void 0 ? _a : {};
      headers = Object.assign({ Authorization: this.params.apiKey, "Content-Type": "application/json" }, init.headers);
      if (this.userAgent) {
        headers["User-Agent"] = this.userAgent;
        if (typeof window !== "undefined" && "chrome" in window) {
          headers["AssemblyAI-Agent"] = this.userAgent;
        }
      }
      init.headers = headers;
      init.cache = "no-store";
      if (!input.startsWith("http"))
        input = this.params.baseUrl + input;
      const response = yield fetch(input, init);
      if (response.status >= 400) {
        let json;
        const text = yield response.text();
        if (text) {
          try {
            json = JSON.parse(text);
          } catch (_b) {
          }
          if (json === null || json === void 0 ? void 0 : json.error)
            throw new Error(json.error);
          throw new Error(text);
        }
        throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
      }
      return response;
    });
  }
  fetchJson(input, init) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.fetch(input, init);
      return response.json();
    });
  }
};
var LemurService = class extends BaseService {
  summary(params) {
    return this.fetchJson("/lemur/v3/generate/summary", {
      method: "POST",
      body: JSON.stringify(params)
    });
  }
  questionAnswer(params) {
    return this.fetchJson("/lemur/v3/generate/question-answer", {
      method: "POST",
      body: JSON.stringify(params)
    });
  }
  actionItems(params) {
    return this.fetchJson("/lemur/v3/generate/action-items", {
      method: "POST",
      body: JSON.stringify(params)
    });
  }
  task(params) {
    return this.fetchJson("/lemur/v3/generate/task", {
      method: "POST",
      body: JSON.stringify(params)
    });
  }
  purgeRequestData(id) {
    return this.fetchJson(`/lemur/v3/${id}`, {
      method: "DELETE"
    });
  }
};
var { WritableStream } = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis;
var factory = (url, params) => new import_ws.default(url, params);
var RealtimeErrorType;
(function(RealtimeErrorType2) {
  RealtimeErrorType2[RealtimeErrorType2["BadSampleRate"] = 4e3] = "BadSampleRate";
  RealtimeErrorType2[RealtimeErrorType2["AuthFailed"] = 4001] = "AuthFailed";
  RealtimeErrorType2[RealtimeErrorType2["InsufficientFundsOrFreeAccount"] = 4002] = "InsufficientFundsOrFreeAccount";
  RealtimeErrorType2[RealtimeErrorType2["NonexistentSessionId"] = 4004] = "NonexistentSessionId";
  RealtimeErrorType2[RealtimeErrorType2["SessionExpired"] = 4008] = "SessionExpired";
  RealtimeErrorType2[RealtimeErrorType2["ClosedSession"] = 4010] = "ClosedSession";
  RealtimeErrorType2[RealtimeErrorType2["RateLimited"] = 4029] = "RateLimited";
  RealtimeErrorType2[RealtimeErrorType2["UniqueSessionViolation"] = 4030] = "UniqueSessionViolation";
  RealtimeErrorType2[RealtimeErrorType2["SessionTimeout"] = 4031] = "SessionTimeout";
  RealtimeErrorType2[RealtimeErrorType2["AudioTooShort"] = 4032] = "AudioTooShort";
  RealtimeErrorType2[RealtimeErrorType2["AudioTooLong"] = 4033] = "AudioTooLong";
  RealtimeErrorType2[RealtimeErrorType2["BadJson"] = 4100] = "BadJson";
  RealtimeErrorType2[RealtimeErrorType2["BadSchema"] = 4101] = "BadSchema";
  RealtimeErrorType2[RealtimeErrorType2["TooManyStreams"] = 4102] = "TooManyStreams";
  RealtimeErrorType2[RealtimeErrorType2["Reconnected"] = 4103] = "Reconnected";
  RealtimeErrorType2[RealtimeErrorType2["ReconnectAttemptsExhausted"] = 1013] = "ReconnectAttemptsExhausted";
})(RealtimeErrorType || (RealtimeErrorType = {}));
var RealtimeErrorMessages = {
  [RealtimeErrorType.BadSampleRate]: "Sample rate must be a positive integer",
  [RealtimeErrorType.AuthFailed]: "Not Authorized",
  [RealtimeErrorType.InsufficientFundsOrFreeAccount]: "Insufficient funds or you are using a free account. This feature is paid-only and requires you to add a credit card. Please visit https://assemblyai.com/dashboard/ to add a credit card to your account.",
  [RealtimeErrorType.NonexistentSessionId]: "Session ID does not exist",
  [RealtimeErrorType.SessionExpired]: "Session has expired",
  [RealtimeErrorType.ClosedSession]: "Session is closed",
  [RealtimeErrorType.RateLimited]: "Rate limited",
  [RealtimeErrorType.UniqueSessionViolation]: "Unique session violation",
  [RealtimeErrorType.SessionTimeout]: "Session Timeout",
  [RealtimeErrorType.AudioTooShort]: "Audio too short",
  [RealtimeErrorType.AudioTooLong]: "Audio too long",
  [RealtimeErrorType.BadJson]: "Bad JSON",
  [RealtimeErrorType.BadSchema]: "Bad schema",
  [RealtimeErrorType.TooManyStreams]: "Too many streams",
  [RealtimeErrorType.Reconnected]: "Reconnected",
  [RealtimeErrorType.ReconnectAttemptsExhausted]: "Reconnect attempts exhausted"
};
var RealtimeError = class extends Error {
};
var defaultRealtimeUrl = "wss://api.assemblyai.com/v2/realtime/ws";
var forceEndOfUtteranceMessage = `{"force_end_utterance":true}`;
var terminateSessionMessage = `{"terminate_session":true}`;
var RealtimeTranscriber = class {
  constructor(params) {
    var _a, _b;
    this.listeners = {};
    this.realtimeUrl = (_a = params.realtimeUrl) !== null && _a !== void 0 ? _a : defaultRealtimeUrl;
    this.sampleRate = (_b = params.sampleRate) !== null && _b !== void 0 ? _b : 16e3;
    this.wordBoost = params.wordBoost;
    this.encoding = params.encoding;
    this.endUtteranceSilenceThreshold = params.endUtteranceSilenceThreshold;
    this.disablePartialTranscripts = params.disablePartialTranscripts;
    if ("token" in params && params.token)
      this.token = params.token;
    if ("apiKey" in params && params.apiKey)
      this.apiKey = params.apiKey;
    if (!(this.token || this.apiKey)) {
      throw new Error("API key or temporary token is required.");
    }
  }
  connectionUrl() {
    const url = new URL(this.realtimeUrl);
    if (url.protocol !== "wss:") {
      throw new Error("Invalid protocol, must be wss");
    }
    const searchParams = new URLSearchParams();
    if (this.token) {
      searchParams.set("token", this.token);
    }
    searchParams.set("sample_rate", this.sampleRate.toString());
    if (this.wordBoost && this.wordBoost.length > 0) {
      searchParams.set("word_boost", JSON.stringify(this.wordBoost));
    }
    if (this.encoding) {
      searchParams.set("encoding", this.encoding);
    }
    searchParams.set("enable_extra_session_information", "true");
    if (this.disablePartialTranscripts) {
      searchParams.set("disable_partial_transcripts", this.disablePartialTranscripts.toString());
    }
    url.search = searchParams.toString();
    return url;
  }
  on(event, listener) {
    this.listeners[event] = listener;
  }
  connect() {
    return new Promise((resolve) => {
      if (this.socket) {
        throw new Error("Already connected");
      }
      const url = this.connectionUrl();
      if (this.token) {
        this.socket = factory(url.toString());
      } else {
        this.socket = factory(url.toString(), {
          headers: { Authorization: this.apiKey }
        });
      }
      this.socket.binaryType = "arraybuffer";
      this.socket.onopen = () => {
        if (this.endUtteranceSilenceThreshold === void 0 || this.endUtteranceSilenceThreshold === null) {
          return;
        }
        this.configureEndUtteranceSilenceThreshold(this.endUtteranceSilenceThreshold);
      };
      this.socket.onclose = ({ code, reason }) => {
        var _a, _b;
        if (!reason) {
          if (code in RealtimeErrorType) {
            reason = RealtimeErrorMessages[code];
          }
        }
        (_b = (_a = this.listeners).close) === null || _b === void 0 ? void 0 : _b.call(_a, code, reason);
      };
      this.socket.onerror = (event) => {
        var _a, _b, _c, _d;
        if (event.error)
          (_b = (_a = this.listeners).error) === null || _b === void 0 ? void 0 : _b.call(_a, event.error);
        else
          (_d = (_c = this.listeners).error) === null || _d === void 0 ? void 0 : _d.call(_c, new Error(event.message));
      };
      this.socket.onmessage = ({ data }) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const message = JSON.parse(data.toString());
        if ("error" in message) {
          (_b = (_a = this.listeners).error) === null || _b === void 0 ? void 0 : _b.call(_a, new RealtimeError(message.error));
          return;
        }
        switch (message.message_type) {
          case "SessionBegins": {
            const openObject = {
              sessionId: message.session_id,
              expiresAt: new Date(message.expires_at)
            };
            resolve(openObject);
            (_d = (_c = this.listeners).open) === null || _d === void 0 ? void 0 : _d.call(_c, openObject);
            break;
          }
          case "PartialTranscript": {
            message.created = new Date(message.created);
            (_f = (_e = this.listeners).transcript) === null || _f === void 0 ? void 0 : _f.call(_e, message);
            (_h = (_g = this.listeners)["transcript.partial"]) === null || _h === void 0 ? void 0 : _h.call(_g, message);
            break;
          }
          case "FinalTranscript": {
            message.created = new Date(message.created);
            (_k = (_j = this.listeners).transcript) === null || _k === void 0 ? void 0 : _k.call(_j, message);
            (_m = (_l = this.listeners)["transcript.final"]) === null || _m === void 0 ? void 0 : _m.call(_l, message);
            break;
          }
          case "SessionInformation": {
            (_p = (_o = this.listeners).session_information) === null || _p === void 0 ? void 0 : _p.call(_o, message);
            break;
          }
          case "SessionTerminated": {
            (_q = this.sessionTerminatedResolve) === null || _q === void 0 ? void 0 : _q.call(this);
            break;
          }
        }
      };
    });
  }
  sendAudio(audio) {
    this.send(audio);
  }
  stream() {
    return new WritableStream({
      write: (chunk) => {
        this.sendAudio(chunk);
      }
    });
  }
  forceEndUtterance() {
    this.send(forceEndOfUtteranceMessage);
  }
  configureEndUtteranceSilenceThreshold(threshold) {
    this.send(`{"end_utterance_silence_threshold":${threshold}}`);
  }
  send(data) {
    if (!this.socket || this.socket.readyState !== this.socket.OPEN) {
      throw new Error("Socket is not open for communication");
    }
    this.socket.send(data);
  }
  close() {
    return __awaiter(this, arguments, void 0, function* (waitForSessionTermination = true) {
      var _a;
      if (this.socket) {
        if (this.socket.readyState === this.socket.OPEN) {
          if (waitForSessionTermination) {
            const sessionTerminatedPromise = new Promise((resolve) => {
              this.sessionTerminatedResolve = resolve;
            });
            this.socket.send(terminateSessionMessage);
            yield sessionTerminatedPromise;
          } else {
            this.socket.send(terminateSessionMessage);
          }
        }
        if ((_a = this.socket) === null || _a === void 0 ? void 0 : _a.removeAllListeners)
          this.socket.removeAllListeners();
        this.socket.close();
      }
      this.listeners = {};
      this.socket = void 0;
    });
  }
};
var RealtimeService = class extends RealtimeTranscriber {
};
var RealtimeTranscriberFactory = class extends BaseService {
  constructor(params) {
    super(params);
    this.rtFactoryParams = params;
  }
  createService(params) {
    return this.transcriber(params);
  }
  transcriber(params) {
    const serviceParams = Object.assign({}, params);
    if (!serviceParams.token && !serviceParams.apiKey) {
      serviceParams.apiKey = this.rtFactoryParams.apiKey;
    }
    return new RealtimeTranscriber(serviceParams);
  }
  createTemporaryToken(params) {
    return __awaiter(this, void 0, void 0, function* () {
      const data = yield this.fetchJson("/v2/realtime/token", {
        method: "POST",
        body: JSON.stringify(params)
      });
      return data.token;
    });
  }
};
var RealtimeServiceFactory = class extends RealtimeTranscriberFactory {
};
function getPath(path) {
  if (path.startsWith("http"))
    return null;
  if (path.startsWith("https"))
    return null;
  if (path.startsWith("data:"))
    return null;
  if (path.startsWith("file://"))
    return path.substring(7);
  if (path.startsWith("file:"))
    return path.substring(5);
  return path;
}
var TranscriptService = class extends BaseService {
  constructor(params, files) {
    super(params);
    this.files = files;
  }
  transcribe(params, options) {
    return __awaiter(this, void 0, void 0, function* () {
      deprecateConformer2(params);
      const transcript = yield this.submit(params);
      return yield this.waitUntilReady(transcript.id, options);
    });
  }
  submit(params) {
    return __awaiter(this, void 0, void 0, function* () {
      deprecateConformer2(params);
      let audioUrl;
      let transcriptParams = void 0;
      if ("audio" in params) {
        const { audio } = params, audioTranscriptParams = __rest(params, ["audio"]);
        if (typeof audio === "string") {
          const path = getPath(audio);
          if (path !== null) {
            audioUrl = yield this.files.upload(path);
          } else {
            if (audio.startsWith("data:")) {
              audioUrl = yield this.files.upload(audio);
            } else {
              audioUrl = audio;
            }
          }
        } else {
          audioUrl = yield this.files.upload(audio);
        }
        transcriptParams = Object.assign(Object.assign({}, audioTranscriptParams), { audio_url: audioUrl });
      } else {
        transcriptParams = params;
      }
      const data = yield this.fetchJson("/v2/transcript", {
        method: "POST",
        body: JSON.stringify(transcriptParams)
      });
      return data;
    });
  }
  create(params, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      deprecateConformer2(params);
      const path = getPath(params.audio_url);
      if (path !== null) {
        const uploadUrl = yield this.files.upload(path);
        params.audio_url = uploadUrl;
      }
      const data = yield this.fetchJson("/v2/transcript", {
        method: "POST",
        body: JSON.stringify(params)
      });
      if ((_a = options === null || options === void 0 ? void 0 : options.poll) !== null && _a !== void 0 ? _a : true) {
        return yield this.waitUntilReady(data.id, options);
      }
      return data;
    });
  }
  waitUntilReady(transcriptId, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const pollingInterval = (_a = options === null || options === void 0 ? void 0 : options.pollingInterval) !== null && _a !== void 0 ? _a : 3e3;
      const pollingTimeout = (_b = options === null || options === void 0 ? void 0 : options.pollingTimeout) !== null && _b !== void 0 ? _b : -1;
      const startTime = Date.now();
      while (true) {
        const transcript = yield this.get(transcriptId);
        if (transcript.status === "completed" || transcript.status === "error") {
          return transcript;
        } else if (pollingTimeout > 0 && Date.now() - startTime > pollingTimeout) {
          throw new Error("Polling timeout");
        } else {
          yield new Promise((resolve) => setTimeout(resolve, pollingInterval));
        }
      }
    });
  }
  get(id) {
    return this.fetchJson(`/v2/transcript/${id}`);
  }
  list(params) {
    return __awaiter(this, void 0, void 0, function* () {
      let url = "/v2/transcript";
      if (typeof params === "string") {
        url = params;
      } else if (params) {
        url = `${url}?${new URLSearchParams(Object.keys(params).map((key) => {
          var _a;
          return [
            key,
            ((_a = params[key]) === null || _a === void 0 ? void 0 : _a.toString()) || ""
          ];
        }))}`;
      }
      const data = yield this.fetchJson(url);
      for (const transcriptListItem of data.transcripts) {
        transcriptListItem.created = new Date(transcriptListItem.created);
        if (transcriptListItem.completed) {
          transcriptListItem.completed = new Date(transcriptListItem.completed);
        }
      }
      return data;
    });
  }
  delete(id) {
    return this.fetchJson(`/v2/transcript/${id}`, { method: "DELETE" });
  }
  wordSearch(id, words) {
    const params = new URLSearchParams({ words: words.join(",") });
    return this.fetchJson(`/v2/transcript/${id}/word-search?${params.toString()}`);
  }
  sentences(id) {
    return this.fetchJson(`/v2/transcript/${id}/sentences`);
  }
  paragraphs(id) {
    return this.fetchJson(`/v2/transcript/${id}/paragraphs`);
  }
  subtitles(id_1) {
    return __awaiter(this, arguments, void 0, function* (id, format = "srt", chars_per_caption) {
      let url = `/v2/transcript/${id}/${format}`;
      if (chars_per_caption) {
        const params = new URLSearchParams();
        params.set("chars_per_caption", chars_per_caption.toString());
        url += `?${params.toString()}`;
      }
      const response = yield this.fetch(url);
      return yield response.text();
    });
  }
  redactions(id) {
    return this.fetchJson(`/v2/transcript/${id}/redacted-audio`);
  }
};
function deprecateConformer2(params) {
  if (!params)
    return;
  if (params.speech_model === "conformer-2") {
    console.warn("The speech_model conformer-2 option is deprecated and will stop working in the near future. Use best or nano instead.");
  }
}
var readFile = function(path) {
  return __awaiter(this, void 0, void 0, function* () {
    throw new Error("Interacting with the file system is not supported in this environment.");
  });
};
var FileService = class extends BaseService {
  upload(input) {
    return __awaiter(this, void 0, void 0, function* () {
      let fileData;
      if (typeof input === "string") {
        if (input.startsWith("data:")) {
          fileData = dataUrlToBlob(input);
        } else {
          fileData = yield readFile();
        }
      } else
        fileData = input;
      const data = yield this.fetchJson("/v2/upload", {
        method: "POST",
        body: fileData,
        headers: {
          "Content-Type": "application/octet-stream"
        },
        duplex: "half"
      });
      return data.upload_url;
    });
  }
};
function dataUrlToBlob(dataUrl) {
  const arr = dataUrl.split(",");
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
}
var defaultBaseUrl = "https://api.assemblyai.com";
var AssemblyAI = class {
  constructor(params) {
    params.baseUrl = params.baseUrl || defaultBaseUrl;
    if (params.baseUrl && params.baseUrl.endsWith("/")) {
      params.baseUrl = params.baseUrl.slice(0, -1);
    }
    this.files = new FileService(params);
    this.transcripts = new TranscriptService(params, this.files);
    this.lemur = new LemurService(params);
    this.realtime = new RealtimeTranscriberFactory(params);
  }
};
export {
  AssemblyAI,
  FileService,
  LemurService,
  RealtimeService,
  RealtimeServiceFactory,
  RealtimeTranscriber,
  RealtimeTranscriberFactory,
  TranscriptService
};
//# sourceMappingURL=assemblyai.js.map
